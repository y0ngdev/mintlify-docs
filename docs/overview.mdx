---
title:  Welcome to the API
description: 'Our philosophy for building developer-friendly APIs'
---


We designed our API from the ground up to be developer-friendly. Our goal is to make your integration as smooth as possible by following three key principles:

* **Predictable Patterns**: Once you learn how to use one endpoint, you'll instinctively know how to use all of them.
* **Practical Design**: We favor practical, real-world solutions over rigid, purist standards.
* **Clear Communication**: Our structured responses make it easy to understand what happened, whether the request was a success or a failure.

### The Standard Response Envelope

All API responses—whether successful or not—follow the same consistent JSON structure. This "envelope" makes it simple to write reusable, reliable code to handle any response.

At a minimum, you'll always receive a `meta` object (for tracking) and a `data` object (for the result).

```json
{
  "meta": {
    "requestId": "req_abc123xyz789"
  },
  "data": {
    "id": "key_123",
    "status": "active"
  }
}
```

When you request a list of items, we'll also include a `pagination` object to help you navigate large result sets.

```json
{
  "meta": {
    "requestId": "req_abc123xyz789",
    "timestamp": "2023-11-08T15:22:30Z"
  },
  "data": [
   { "id": "item_1" },
   { "id": "item_2" }
  ],
  "pagination": {
    "cursor": "cursor_xyz123",
    "hasMore": true
  }
}
```



### Your Debugging Lifeline: The Request ID

Every API response, in its `meta` object, includes a unique `requestId`.

**This is the most important piece of information for debugging.** If you ever encounter an issue or need to contact support, providing this ID allows us to find the exact trace of your request in our logs and help you immediately.

You can also use this `requestId` to find the request yourself in the dashboard logs.


### How to Handle Pagination

For any endpoint that returns a list, you'll need to check for pagination.

1.  Make your first request to the list endpoint.
2.  Check the `pagination.hasMore` boolean.
3.  If `hasMore` is `true`, it means there are more results available.
4.  To get the next page, make the **exact same request**, but this time, add the `pagination.cursor` value to your request body.

**Example (JavaScript):**

```js
// Make the first request
const response = await fetch('https://api.example.com/keys/list', {
  method: 'POST',
  headers: { Authorization: `Bearer ${rootKey}` },
  body: JSON.stringify({ apiId: 'api_123' })
});

// Check if there's another page
if (response.pagination?.hasMore) {
  
  // Fetch the next page using the cursor from the first response
  const nextPage = await fetch('https://api.example.com/keys/list', {
    method: 'POST',
    headers: { Authorization: `Bearer ${rootKey}` },
    body: JSON.stringify({
      apiId: 'api_123',
      cursor: response.pagination.cursor // <-- Use the cursor here
    })
  });
}
```



### Our Stability Promise: Versioning

We know that API stability is critical. We use major versioning in the URL path (e.g., `/v2/`) to ensure we can make improvements without breaking your existing integration.

* **No Breaking Changes**: We will **never** introduce a backwards-incompatible change within a major version (like `/v2/`).
* **Clear Communication**: If we ever need to release a new major version (e.g., `/v3/`), we will announce it well in advance, provide a clear migration guide, and maintain the old version for a generous deprecation period.